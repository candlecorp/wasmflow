pub use async_trait :: async_trait ; pub use wick_component :: wasmrs_rx ; pub use wick_component :: wasmrs_rx :: { Observer , Observable } ; pub use wick_component :: runtime ; pub use wick_component :: wasmrs ; pub use wick_component :: packet as wick_packet ; pub use wick_component :: wasmrs_codec ; # [allow (unused)] pub (crate) type WickStream < T > = wick_component :: wasmrs_rx :: BoxFlux < T , wick_component :: anyhow :: Error > ; pub use wick_component :: anyhow :: Result ; # [no_mangle] # [cfg (target_family = "wasm")] extern "C" fn __wasmrs_init (guest_buffer_size : u32 , host_buffer_size : u32 , max_host_frame_len : u32) { wasmrs_guest :: init (guest_buffer_size , host_buffer_size , max_host_frame_len) ; wasmrs_guest :: register_request_response ("wick" , "__setup" , Box :: new (__setup)) ; wasmrs_guest :: register_request_channel ("wick" , "error" , Box :: new (Component :: error_wrapper)) ; wasmrs_guest :: register_request_channel ("wick" , "validate" , Box :: new (Component :: validate_wrapper)) ; wasmrs_guest :: register_request_channel ("wick" , "add" , Box :: new (Component :: add_wrapper)) ; } # [cfg (target_family = "wasm")] thread_local ! { static __CONFIG : std :: cell :: UnsafeCell < Option < SetupPayload >> = std :: cell :: UnsafeCell :: new (None) ; } # [cfg (target_family = "wasm")] # [derive (Debug , serde :: Deserialize)] pub (crate) struct SetupPayload { # [allow (unused)] pub (crate) provided : std :: collections :: HashMap < String , wick_packet :: ComponentReference > } # [cfg (target_family = "wasm")] fn __setup (input : wasmrs_rx :: BoxMono < wasmrs :: Payload , wasmrs :: PayloadError >) -> Result < wasmrs_rx :: BoxMono < wasmrs :: RawPayload , wasmrs :: PayloadError > , wick_component :: BoxError > { Ok (wasmrs_rx :: Mono :: from_future (async move { match input . await { Ok (payload) => { let input = wasmrs_codec :: messagepack :: deserialize :: < SetupPayload > (& payload . data) . unwrap () ; __CONFIG . with (| cell | { # [allow (unsafe_code)] unsafe { & mut * cell . get () } . replace (input) ; }) ; Ok (wasmrs :: RawPayload :: new_data (None , None)) } Err (e) => { return Err (e) ; } } }) . boxed ()) } # [allow (unused)] # [cfg (target_family = "wasm")] pub (crate) fn get_config () -> & 'static SetupPayload { __CONFIG . with (| cell | { # [allow (unsafe_code)] unsafe { & * cell . get () } . as_ref () . unwrap () }) } pub mod types { # [allow (unused)] use super :: types ; } pub struct OpErrorOutputs { # [allow (unused)] pub (crate) output : wick_packet :: Output < String > , } impl OpErrorOutputs { pub fn new (channel : wasmrs_rx :: FluxChannel < wasmrs :: RawPayload , wasmrs :: PayloadError >) -> Self { Self { output : wick_packet :: Output :: new ("output" , channel . clone ()) , } } } # [cfg_attr (target_family = "wasm" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_family = "wasm") , async_trait :: async_trait)] pub trait OpError { # [allow (unused)] async fn error (input : WickStream < String > , outputs : OpErrorOutputs) -> Result < () > { unimplemented ! () } } pub struct OpValidateOutputs { # [allow (unused)] pub (crate) output : wick_packet :: Output < String > , } impl OpValidateOutputs { pub fn new (channel : wasmrs_rx :: FluxChannel < wasmrs :: RawPayload , wasmrs :: PayloadError >) -> Self { Self { output : wick_packet :: Output :: new ("output" , channel . clone ()) , } } } # [cfg_attr (target_family = "wasm" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_family = "wasm") , async_trait :: async_trait)] pub trait OpValidate { # [allow (unused)] async fn validate (input : WickStream < String > , outputs : OpValidateOutputs) -> Result < () > { unimplemented ! () } } pub struct OpAddOutputs { # [allow (unused)] pub (crate) output : wick_packet :: Output < u64 > , } impl OpAddOutputs { pub fn new (channel : wasmrs_rx :: FluxChannel < wasmrs :: RawPayload , wasmrs :: PayloadError >) -> Self { Self { output : wick_packet :: Output :: new ("output" , channel . clone ()) , } } } # [cfg_attr (target_family = "wasm" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_family = "wasm") , async_trait :: async_trait)] pub trait OpAdd { # [allow (unused)] async fn add (left : WickStream < u64 > , right : WickStream < u64 > , outputs : OpAddOutputs) -> Result < () > { unimplemented ! () } } # [derive (Default , Clone)] pub struct Component ; impl Component { fn error_wrapper (mut input : wasmrs_rx :: BoxFlux < wasmrs :: Payload , wasmrs :: PayloadError >) -> std :: result :: Result < wasmrs_rx :: BoxFlux < wasmrs :: RawPayload , wasmrs :: PayloadError > , Box < dyn std :: error :: Error + Send + Sync >> { let (channel , rx) = wasmrs_rx :: FluxChannel :: < wasmrs :: RawPayload , wasmrs :: PayloadError > :: new_parts () ; let outputs = OpErrorOutputs :: new (channel . clone ()) ; runtime :: spawn (async move { let input = wick_component :: payload_fan_out ! (input , raw : false , [("input" , String) ,]) ; if let Err (e) = Component :: error (Box :: pin (input) , outputs) . await { let _ = channel . send_result (wick_packet :: Packet :: component_error (e . to_string ()) . into () ,) ; } }) ; Ok (Box :: pin (rx)) } fn validate_wrapper (mut input : wasmrs_rx :: BoxFlux < wasmrs :: Payload , wasmrs :: PayloadError >) -> std :: result :: Result < wasmrs_rx :: BoxFlux < wasmrs :: RawPayload , wasmrs :: PayloadError > , Box < dyn std :: error :: Error + Send + Sync >> { let (channel , rx) = wasmrs_rx :: FluxChannel :: < wasmrs :: RawPayload , wasmrs :: PayloadError > :: new_parts () ; let outputs = OpValidateOutputs :: new (channel . clone ()) ; runtime :: spawn (async move { let input = wick_component :: payload_fan_out ! (input , raw : false , [("input" , String) ,]) ; if let Err (e) = Component :: validate (Box :: pin (input) , outputs) . await { let _ = channel . send_result (wick_packet :: Packet :: component_error (e . to_string ()) . into () ,) ; } }) ; Ok (Box :: pin (rx)) } fn add_wrapper (mut input : wasmrs_rx :: BoxFlux < wasmrs :: Payload , wasmrs :: PayloadError >) -> std :: result :: Result < wasmrs_rx :: BoxFlux < wasmrs :: RawPayload , wasmrs :: PayloadError > , Box < dyn std :: error :: Error + Send + Sync >> { let (channel , rx) = wasmrs_rx :: FluxChannel :: < wasmrs :: RawPayload , wasmrs :: PayloadError > :: new_parts () ; let outputs = OpAddOutputs :: new (channel . clone ()) ; runtime :: spawn (async move { let (left , right ,) = wick_component :: payload_fan_out ! (input , raw : false , [("left" , u64) , ("right" , u64) ,]) ; if let Err (e) = Component :: add (Box :: pin (left) , Box :: pin (right) , outputs) . await { let _ = channel . send_result (wick_packet :: Packet :: component_error (e . to_string ()) . into () ,) ; } }) ; Ok (Box :: pin (rx)) } }